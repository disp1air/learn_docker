https://codefresh.io/docker-tutorial/docker-machine-basics/


A Docker host is a physical computer system or virtual machine running Linux. This can be your laptop, server or virtual machine in your data center, or computing resource provided by a cloud provider.

The component on the host that does the work of building and running containers is the Docker Daemon. The daemon starts each container using a template for the container’s specific runtime environment called an image, which is retrieved from an image repository, like the public repositories hosted at Docker Hub.  

Контейнеры представляют собой средства инкапсуляции приложения вместе с его зависимостями. Как и виртуальная машина, контейнер содержит изолированный экземпляр операционной системы (ОС), который можно использовать для запуска приложений.  

контейнеры совместно используют ресурсы основной ОС  

В отличие от виртуальных машин, ядро хоста совместно используется (разделяется) работающими контейнерами. Это означает, что контейнеры всегда ограничиваются использованием того же ядра, которое функционирует на хосте.   

Внутренний механизм контейнера отвечает за пуск и остановку контейнеров так же, как гипервизор в виртуальной машине.  

Платформа Docker состоит из двух отдельных компонентов: Docker Engine, механизма, отвечающего за создание и функционирование контейнеров, и Docker Hub, облачного сервиса для распространения контейнеров.  

Механизм Docker Engine предоставляет эффективный и удобный интерфейс
для запуска контейнеров. 

            $ docker run debian echo "Hello World"  

После загрузки и проверки образа Docker помещает его в работающий контейнер и выполняет заданную команду echo "Hello World" внутри контейнера.  

            $ docker run -i -t debian /bin/bash
            root@622ac5689680:/# echo "Hello from Container-land!"
            Hello from Container-land!
            root@622ac5689680:/# exit
            exit  

Флаги -i и -t сообщают Docker, что необходимо создать сеанс интерактивной работы на подключаемом терминальном устройстве tty. Команда /bin/bash инициализирует командную оболочку bash. При выходе из командной оболочки контейнер прекратит работу – контейнеры работают, пока существует их основной процесс.  

(stdin, stdout, and ttys - связанные понятия. stdin и stdout являются входными и выходными потоками процесса. Псевдотерминал (также известный как tty или pts) соединяет пользовательский "терминал" с потоком stdin и stdout, обычно (но не обязательно) через оболочку, такую как bash.)

Docker генерирует имена в виде случайного прилагательного, за которым следует имя известного ученого, инженера или хакера. Вы можете задать любое имя с помощью аргумента --name (например, docker run --name boris debian echo "Boo").  

Сначала инициализируем новый контейнер, но в этот раз зададим для него имя хоста с помощью флага -h:  

            $ docker run -h CONTAINER -i -t debian /bin/bash  

о имени хоста:  

            $ docker run -h host_name -i -t debian /bin/bash  
            root@host_name:/# ls  
            bin  boot  dev	etc  home  lib	lib64  media  mnt  opt	proc  root  run  sbin  srv  sys  tmp  usr  var  
            root@host_name:/# exit
            exit  

Больше информации о конкретном контейнере можно получить с помощью команды docker inspect с указанием имени или идентификатора нужного контейнера:

            $ docker inspect stupefied_turing  

Здесь выводится огромное количество важной информации, но изучать ее достаточно трудно. Можно воспользоваться утилитой grep для выделения той информации, которая нас интересует. Например:  

            $ docker inspect stupefied_turing | grep IPAddress  
            "IPAddress": "172.17.0.4",  
            "SecondaryIPAddress": null,  

            $ docker inspect --format {{.NetworkSettings.IPAddress}} stupefied_turing
            172.17.0.4  

Обе команды выдают IP-адрес работающего контейнера.  

            $ docker diff stupefied_turing  

Здесь мы видим список файлов, измененных в работающем контейнере;
Для контейнеров Docker использует файловую систему UnionFS (Union File System), которая позволяет монтировать несколько файловых систем в общую иерархию, которая выглядит как единая файловая система. Файловая система конкретного образа смонтирована как уровень только для чтения, а любые изменения в работающем контейнере происходят на уровне с разрешенной записью, монтируемого поверх основной файловой системы образа. Поэтому Docker при поиске изменений в работающей системе должен рассматривать только самый верхний уровень, на котором возможна запись.  

docker logs - будет выведен список всех событий, произошедших внутри заданного контейнера:  

            $ docker logs stupefied_turing  

Чтобы окончательно избавиться от контейнера, следует воспользоваться командой docker rm:  

            $ docker rm stupefied_turing
            stupefied_turing  

Удаление остановленных контейнеров - если необходимо удалить все остановленные контейнеры, можно использовать результат выполнения команды

            $ docker ps -aq -f status=exited  

которая выводит идентификаторы всех остановленных контейнеров. Например:

            $ docker rm -v $(docker ps -aq -f status=exited)


Создание образов из файлов Dockerfile  
Dockerfile – это обычный текстовый файл, содержащий набор операций, которые могут быть использованы для создания Docker-образа.  

Образы, контейнеры и файловая система Union File System  
Чтобы понять взаимосвязь между образами и контейнерами, необходимо более подробно рассмотреть ключевой элемент технологии, лежащей в основе Docker, –
UFS (иногда используется термин каскадно-объединенное монтирование (union mount)). Файловые системы с каскадно-объединенным монтированием позволяют подключать несколько файловых систем с перекрытием (или наложением друг на друга), причем для пользователя они будут выглядеть как одна файловая система. Каталоги могут содержать файлы из нескольких файловых систем, но если двум файлам в точности соответствует один и тот же путь, то файл, смонтированный самым последним, скроет все ранее монтированные файлы. Docker поддерживает несколько различных реализаций UnionFS, включая AUFS, Overlay, devicemapper, BTRFS и ZFS. Реализацию, используемую в конкретной системе, можно определить командой docker info – смотреть содержимое заголовка «Storage Driver».  

Образы Docker состоят из нескольких уровней (layers). Каждый уровень представляет собой защищенную от записи файловую систему. Для каждой инструкции в Dockerfile создается свой уровень, который размещается поверх предыдущих уровней. Во время преобразования образа в контейнер (командой docker run
или docker create) механизм Docker выбирает нужный образ и добавляет на самом верхнем уровне файловую систему с возможностью записи (одновременно с этим инициализируются разнообразные параметры настройки, такие как IP-адрес, имя, идентификатор и ограничения ресурсов).  

Поскольку ненужные уровни значительно увеличивают размеры образов (а для файловой системы AUFS установлен строгий лимит, равный 127 уровням), во многих файлах Dockerfile можно обнаружить попытку свести к минимуму количество уровней посредством записи нескольких команд Unix в одной инструкции RUN.  

Контейнер может находиться в одном из следующих состояний: created, restarting, running, paused или exited. «Созданным» считается контейнер, который был инициализирован командой docker create, но его работа пока еще не началась. Состояние exited в общем случае соответствует состоянию «остановлен» (stopped), когда в данном контейнере нет активно выполняющихся процессов (их нет и в «созданном» контейнере, но остановленный контейнер уже запускался, по крайней мере один раз). Контейнер существует, пока существует его основной процесс. Остановленный контейнер можно перезапустить командой docker start. Остановленный контейнер – это не то же самое, что исходный образ. Остановленный контейнер сохраняет все изменения в его параметрах настройки, метаданных и файловой системе, в том числе и параметры конфигурации времени выполнения, например IP-адрес, которые не хранятся в образах. Состояние перезапуска на практике встречается редко и возникает в тех случаях, когда механизм Docker пытается повторно запустить контейнер после неудачной первой попытки.  

ENTRYPOINT. Эта инструкция позволяет определить выполняемый файл, который будет вызываться для обработки любых аргументов, переданных в команду docker run.  

Инструкция COPY просто копирует файл из файловой системы хоста в файловую систему образа, где первый аргумент определяет файл хоста, а второй – целевой путь, таким образом, эта инструкция очень похожа на обычную команду cp.  



Для установления соединения между контейнерами в сети используется команда --link.  

Установление соединения определяется аргументом --link myredis:redis в команде docker run. Docker получает информацию о том, что нам нужно установить
соединение между новым контейнером и существующим контейнером myredis, и в новом контейнере ссылка на существующий должна быть обозначена именем
redis. Для этого Docker создает в файле нового контейнера /etc/hosts запись redis, указывающую на IP-адрес контейнера myredis. Это позволяет нам пользоваться именем хоста redis непосредственно в командной строке redis-cli, без дополнительного определения пути к нему или поиска IP-адреса контейнера Redis. После этого выполняется команда СУБД Redis ping для проверки правильности установленного соединения с Redis-сервером перед добавлением и извлечением каких-либо данных с помощью команд set и put.  

Все выглядит замечательно, но остался один вопрос: как сохранить наши данные и создать их резервную копию? Для этого не следует использовать стандартную файловую систему контейнера, необходима возможность простого совместного использования хранилища данных контейнером и хостом или другими контейнерами. Docker предоставляет такую возможность посредством реализации концепции томов. Тома (volumes) – это файлы или каталоги, которые смонтированы непосредственно на хосте и не являются частью каскадно-объединенной файловой системы. Это означает, что другие контейнеры могут совместно использовать их, и все изменения будут сразу же фиксироваться в файловой системе хоста. Существуют два способа объявления каталога как тома: использование инструкции VOLUME в Dockerfile или включение флага -v в команду docker run. Ниже приведены примеры реализации обоих способов с одинаковым результатом – определение каталога /data как тома внутри контейнера:  

VOLUME /data
или
$ docker run -v /data test/webserver 

По умолчанию заданный каталог или файл будет смонтирован на хосте внутри каталога, в котором был установлен Docker (обычно это каталог /var/lib/docker/).  

КАК СОЗДАЮТСЯ ОБРАЗЫ  
Для команды docker build необходим Dockerfile и контекст создания образа (build context) (который может быть пустым). Контекст создания – это набор локальных файлов и каталогов, к которым можно обращаться из инструкций ADD и/или COPY в Dockerfile и которые обычно определяются как путь к нужному каталогу. Например мы использовали команду создания образа docker build -t test/cowsay-dockerfile . которая определяла контекст создания как '.', то есть текущий рабочий каталог. Все файлы и каталоги, расположенные по указанному пути, формируют контекст создания образа и передаются в демон Docker как часть процесса создания. В тех случаях, когда контекст не определен, – если задан только URL для Dockerfile или содержимое Dockerfile передается по программному каналу из стандартного потока ввода (STDIN), – контекст создания данного образа считается пустым.  

Поскольку контекст создания образа полностью включается в tar-архив и передается в демон Docker, не используйте для этой цели каталога, в котором содержится большое количество файлов.  

В качестве контекста создания образа разрешается указывать git-репозиторий. В этом случае клиент Docker создает клон такого репозитория и всех подчиненных модулей во временном каталоге, который затем передается в демон Docker как контекст создания образа.  

Для удаления ненужных файлов из контекста создания образа можно воспользоваться файлом .dockerignore. Этот файл должен содержать имена исключаемых файлов, разделенных символами перехода на новую строку. Допускаются символы шаблонов * и ?. Например, можно сформировать .dockerignore со следующим содержимым:

    .git  
    */.git  
    */*/.git  
    *.sw?  

Из контекста исключается файл или каталог .git в корневом каталоге контекста создания образа, но при этом в контекст включается такой файл в любом
подкаталоге (таким образом .git исключается, но dir1/.git1 включается).

Из контекста исключается файл или каталог .git, расположенный в подкаталоге одним уровнем ниже корневого каталога (таким образом dir1/.git исключается, но .git и dir1/dir2/.git включаются).

Из контекста исключается файл или каталог .git, расположенный в подкаталоге двумя уровнями ниже корневого каталога (таким образом dir1/dir2/.git
исключается, но .git и dir1/.git включаются).

Из контекста исключаются файлы test.swp, test.swo и bla.swp, но в контексте остается файл dir1/test.swp.  

Каждая инструкция в Dockerfile приводит к появлению нового уровня (layer) образа, который также может участвовать в запуске контейнера. Новый уровень создается во время запуска контейнера с использованием образа предыдущего уровня при выполнении соответствующей инструкции Dockerfile и с сохранением нового образа. После успешного завершения выполнения инструкции Dockerfile вспомогательный контейнер удаляется, если в команде не был задан аргумент --rm=false Так как результатом выполнения каждой инструкции является создание статического образа – в сущности, это файловая система и некоторые метаданные, – все активные процессы в данной инструкции будут завершены. Поэтому, несмотря на возможность инициализации в инструкции RUN долговременных процессов, подобных демонам СУБД и SSH, любые активные процессы прекратят свою работу при обработке следующей инструкции или при запуске контейнера. Если необходим сервис или процесс, запускаемый вместе с контейнером, его следует инициализировать с помощью инструкции ENTRYPOINT или CMD.  

Следует отметить, что при запуске команды docker build Docker считывает инструкцию FROM и пытается скачать заданный образ, если его нет в локальной системе. Если такой образ существует локально, Docker использует его без проверки доступности новой версии. Это означает, что команда docker build не может гарантировать, что вызываемый образ соответствует самой новой версии, поэтому необходимо явно выполнить команду docker pull для всех родительских образов или удалить их, чтобы команда docker build загрузила самые новые их версии.  

ИНСТРУКЦИИ Dockerfile  

ADD
Копирует файлы из контекста создания или из удаленных URL-ссылок в создаваемый образ. Если архивный файл добавляется из локального пути, то он будет
автоматически распакован.  

CMD
Запускает заданную инструкцию во время инициализации контейнера. Если была определена инструкция ENTRYPOINT, то заданная здесь инструкция будет интерпретироваться как аргумент для ENTRY POINT (в этом случае необходимо использовать формат exec). Инструкция CMD замещается любыми аргументами,
указанными в команде docker run после имени образа. В действительности выполняется только самая последняя инструкция CMD, а все предыдущие инструкции CMD будут отменены (в том числе и содержащиеся в основных образах). 
(простыми словами - указывается какая команда будет запущена при старте имейджа) 

COPY
Используется для копирования файлов из контекста создания в образ. Имеет два формата: COPY источник цель и COPY ["источник", "цель"] – оба копируют
файл или каталог из «источник» в контексте создания в «цель» внутри контейнера. Следует обратить особое внимание на невозможность указания путей «источника», расположенных вне пределов контекста создания (например, нельзя указать для копирования файл ../another_dir/myfile).  

ENTRYPOINT
Определяет выполняемый файл (программу) (и аргументы по умолчанию), запускаемый при инициализации контейнера. В эту выполняемую программу передаются как аргументы любые инструкции CMD или аргументы команды docker run, записанные после имени образа. Инструкции ENTRYPOINT часто используются для организации скриптов запуска, которые инициализируют переменные и сервисы перед обработкой всех передаваемых в образ аргументов.  

EXPOSE
Сообщает механизму Docker о том, что в данном контейнере будет существовать процесс, прослушивающий заданный порт или несколько портов. Механизм Docker использует эту информацию при установлении соединения между контейнерами или при открытии портов для общего доступа при помощи аргумента -P в команде docker run.  

WORKDIR
Определяет рабочий каталог для всех последующих инструкций RUN, CMD, ENTRYPOINT, ADD, COPY. Инструкцию можно использовать несколько раз. Допускается указание относительных путей, при этом итоговый путь определяется относительно ранее указанного рабочего каталога WORKDIR.  

Допустим, вы запустили веб-сервер внутри контейнера. Но как обеспечить связь сервера с внешним миром? Ответ прост – открыть нужные порты для общего доступа с помощью аргументов -p или -P в команде запуска. Такая команда перенаправляет порты хоста в контейнер.  

            $ docker run -d -p 8000:80 nginx  

Аргумент -p 8000:80 сообщил механизму Docker о необходимости перенаправления порта 8000 хоста на порт 80 в контейнере. В качестве альтернативы при использовании аргумента -P механизм Docker должен автоматически выбрать свободный порт для перенаправления с хоста в контейнер.  

Главное преимущество использования аргумента -P заключается в устранении дополнительного уровня ответственности за корректное назначение портов, что
особенно важно при наличии нескольких контейнеров с портами, открытыми для общего доступа. Чтобы определить номера портов, назначенные механизмом
Docker, можно выполнить команду docker port.  

Управление данными с помощью томов и контейнеров данных
Тома (volumes) Docker – это каталоги которые не являются частью файловой системы UnionFS конкретного контейнера а представляют собой обычные каталоги в файловой системе хоста, но могут быть смонтированы как отдельные файловые системы (bind mounting) внутри контейнера.
Существуют три различных способа инициализации томов. Важно хорошо понимать различия между этими способами. Во-первых, можно объявить том при
запуске контейнера с помощью флага -v: 

            $ docker run -it --name container-test -h CONTAINER -v /data debian /bin/bash  
            root@CONTAINER:/# ls /data  
            root@CONTAINER:/#  

Здесь каталог /data внутри контейнера станет томом. Любые файлы, которые данный образ сохранил в каталоге /data, копируются на этот том. Мы можем проверить место расположения данного тома в файловой системе хоста, выполнив команду docker inspect на хосте из новой командной оболочки:  

            $ docker inspect -f {{.Mounts}} container-test
            [{5cad... /mnt/sda1/var/lib/docker/volumes/5cad.../_data /data local true}]

Здесь том /data/ в контейнере представляет собой просто ссылку на каталог /var/lib/docker/volumes/5cad.../_data в файловой системе хоста. Чтобы проверить это на практике, можно добавить файл в указанный каталог хоста  

            $ sudo touch /var/lib/docker/volumes/5cad.../_data/test-file

Этот файл сразу же можно увидеть внутри контейнера:  

            $ root@CONTAINER:/# ls /data
            test-file  

Второй способ – объявление тома с помощью инструкции VOLUME в файле Dockerfile:  

FROM debian:wheezy
VOLUME /data  

Результат будет в точности тот же самый, что при использовании ключа -v в команде docker run.  



docker system prune -a
docker run ..... -e PORT=4000 ... - env переменная  


docker logs {container_id}

docker exec {container_id} ls - эта команда идет внутрь контейнера, запускает команду(ls) и этот вывод возвращает нам  

docker exec -ti {container_id} bash - проанализировать внутренности контейнера

отличия docker run от docker start ?????

read/write layer => Container layer
read layers => image layers  

docker run -d -p 8080:4000 -e PORT=4000 -v $PWD/../container-data:/app/data node_2

в данном примере - $PWD/../container-data:/app/data - означает синхронизировать фолдер на локальной машине(../container-data) с фолдером внутри контейнера(/app/data)  


docker run -it ubuntu /bin/bash
root@3a5cb5ee2b7c:/# cat /etc/os-release
NAME="Ubuntu"
VERSION="18.04.3 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.3 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic

!!! - ll

docker info 


unix socket
tcp socket
