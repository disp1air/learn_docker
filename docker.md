https://codefresh.io/docker-tutorial/docker-machine-basics/


A Docker host is a physical computer system or virtual machine running Linux. This can be your laptop, server or virtual machine in your data center, or computing resource provided by a cloud provider.

The component on the host that does the work of building and running containers is the Docker Daemon. The daemon starts each container using a template for the container’s specific runtime environment called an image, which is retrieved from an image repository, like the public repositories hosted at Docker Hub.  

Контейнеры представляют собой средства инкапсуляции приложения вместе с его зависимостями. Как и виртуальная машина, контейнер содержит изолированный экземпляр операционной системы (ОС), который можно использовать для запуска приложений.  

контейнеры совместно используют ресурсы основной ОС  

В отличие от виртуальных машин, ядро хоста совместно используется (разделяется) работающими контейнерами. Это означает, что контейнеры всегда ограничиваются использованием того же ядра, которое функционирует на хосте.   

Внутренний механизм контейнера отвечает за пуск и остановку контейнеров так же, как гипервизор в виртуальной машине.  

Платформа Docker состоит из двух отдельных компонентов: Docker Engine, механизма, отвечающего за создание и функционирование контейнеров, и Docker Hub, облачного сервиса для распространения контейнеров.  

Механизм Docker Engine предоставляет эффективный и удобный интерфейс для запуска контейнеров. 

            $ docker run debian echo "Hello World"  

docker run - инициализирует запуск контейнеров  
аргумент debian - это имя образа, который мы намерены использовать  

После загрузки и проверки образа Docker помещает его в работающий контейнер и выполняет заданную команду echo "Hello World" внутри контейнера.  

            $ docker run -i -t debian /bin/bash
            root@622ac5689680:/# echo "Hello from Container-land!"
            Hello from Container-land!
            root@622ac5689680:/# exit
            exit  

Флаги -i и -t сообщают Docker, что необходимо создать сеанс интерактивной работы на подключаемом терминальном устройстве tty. Команда /bin/bash инициализирует командную оболочку bash. При выходе из командной оболочки контейнер прекратит работу – контейнеры работают, пока существует их основной процесс.  

(stdin, stdout, and ttys - связанные понятия. stdin и stdout являются входными и выходными потоками процесса. Псевдотерминал (также известный как tty или pts) соединяет пользовательский "терминал" с потоком stdin и stdout, обычно (но не обязательно) через оболочку, такую как bash.)

Docker генерирует имена в виде случайного прилагательного, за которым следует имя известного ученого, инженера или хакера. Вы можете задать любое имя с помощью аргумента --name (например, docker run --name boris debian echo "Boo").  

Сначала инициализируем новый контейнер, но в этот раз зададим для него имя хоста с помощью флага -h:  

            $ docker run -h CONTAINER -i -t debian /bin/bash  

о имени хоста:  

            $ docker run -h host_name -i -t debian /bin/bash  
            root@host_name:/# ls  
            bin  boot  dev	etc  home  lib	lib64  media  mnt  opt	proc  root  run  sbin  srv  sys  tmp  usr  var  
            root@host_name:/# exit
            exit  

Больше информации о конкретном контейнере можно получить с помощью команды docker inspect с указанием имени или идентификатора нужного контейнера:

            $ docker inspect stupefied_turing  

Здесь выводится огромное количество важной информации, но изучать ее достаточно трудно. Можно воспользоваться утилитой grep для выделения той информации, которая нас интересует. Например:  

            $ docker inspect stupefied_turing | grep IPAddress  
            "IPAddress": "172.17.0.4",  
            "SecondaryIPAddress": null,  

            $ docker inspect --format {{.NetworkSettings.IPAddress}} stupefied_turing
            172.17.0.4  

Обе команды выдают IP-адрес работающего контейнера.  

            $ docker diff stupefied_turing  

Здесь мы видим список файлов, измененных в работающем контейнере;
Для контейнеров Docker использует файловую систему UnionFS (Union File System), которая позволяет монтировать несколько файловых систем в общую иерархию, которая выглядит как единая файловая система. Файловая система конкретного образа смонтирована как уровень только для чтения, а любые изменения в работающем контейнере происходят на уровне с разрешенной записью, монтируемого поверх основной файловой системы образа. Поэтому Docker при поиске изменений в работающей системе должен рассматривать только самый верхний уровень, на котором возможна запись.  

docker logs - будет выведен список всех событий, произошедших внутри заданного контейнера:  

            $ docker logs stupefied_turing  

Чтобы окончательно избавиться от контейнера, следует воспользоваться командой docker rm:  

            $ docker rm stupefied_turing
            stupefied_turing  

Удаление остановленных контейнеров - если необходимо удалить все остановленные контейнеры, можно использовать результат выполнения команды

            $ docker ps -aq -f status=exited  

которая выводит идентификаторы всех остановленных контейнеров. Например:

            $ docker rm -v $(docker ps -aq -f status=exited)


Архитектура Docker  
Docker daemon - ответственный за создание, запуск и контроль работы контейнеров, а также за создание и хранение образов. Демон Docker запускается командой docker daemon, обычно об этом заботится операционная система хоста;  

клиент Docker, размещенный в левой части диаграммы, используется для диалога с демоном Docker по протоколу HTTP. По умолчанию это соединение устанавливается через сокет домена Unix.  
Клиент и демон Docker распространяются как отдельные независимые бинарные файлы;  

реестры Docker используются для хранения и распространения образов. Реестром, выбираемым по умолчанию, явялется Docker Hub. Многие организации создают собственные реестры, которые
используются для хранения коммерческих и приватных образов и для устранения накладных расходов, связанных с загрузкой образов через Интернет. Демон Docker загружает образы из реестров по запросу docker pull. Кроме того, он выполняет автоматическую загрузку образов, указанных в запросе docker run и в инструкции FROM файла Dockerfile, если эти образы недоступны на
локальной системе.


Создание образов из файлов Dockerfile  
Dockerfile – это обычный текстовый файл, содержащий набор операций, которые могут быть использованы для создания Docker-образа.  

Образы, контейнеры и файловая система Union File System  
Чтобы понять взаимосвязь между образами и контейнерами, необходимо более подробно рассмотреть ключевой элемент технологии, лежащей в основе Docker, –
UFS (иногда используется термин каскадно-объединенное монтирование (union mount)). Файловые системы с каскадно-объединенным монтированием позволяют подключать несколько файловых систем с перекрытием (или наложением друг на друга), причем для пользователя они будут выглядеть как одна файловая система. Каталоги могут содержать файлы из нескольких файловых систем, но если двум файлам в точности соответствует один и тот же путь, то файл, смонтированный самым последним, скроет все ранее монтированные файлы. Docker поддерживает несколько различных реализаций UnionFS, включая AUFS, Overlay, devicemapper, BTRFS и ZFS. Реализацию, используемую в конкретной системе, можно определить командой docker info – смотреть содержимое заголовка «Storage Driver».  

Образы Docker состоят из нескольких уровней (layers). Каждый уровень представляет собой защищенную от записи файловую систему. Для каждой инструкции в Dockerfile создается свой уровень, который размещается поверх предыдущих уровней. Во время преобразования образа в контейнер (командой docker run или docker create) механизм Docker выбирает нужный образ и добавляет на самом верхнем уровне файловую систему с возможностью записи (одновременно с этим инициализируются разнообразные параметры настройки, такие как IP-адрес, имя, идентификатор и ограничения ресурсов).  

Поскольку ненужные уровни значительно увеличивают размеры образов (а для файловой системы AUFS установлен строгий лимит, равный 127 уровням), во многих файлах Dockerfile можно обнаружить попытку свести к минимуму количество уровней посредством записи нескольких команд Unix в одной инструкции RUN.  

Контейнер может находиться в одном из следующих состояний: created, restarting, running, paused или exited. «Созданным» считается контейнер, который был инициализирован командой docker create, но его работа пока еще не началась. Состояние exited в общем случае соответствует состоянию «остановлен» (stopped), когда в данном контейнере нет активно выполняющихся процессов (их нет и в «созданном» контейнере, но остановленный контейнер уже запускался, по крайней мере один раз). Контейнер существует, пока существует его основной процесс. Остановленный контейнер можно перезапустить командой docker start. Остановленный контейнер – это не то же самое, что исходный образ. Остановленный контейнер сохраняет все изменения в его параметрах настройки, метаданных и файловой системе, в том числе и параметры конфигурации времени выполнения, например IP-адрес, которые не хранятся в образах. Состояние перезапуска на практике встречается редко и возникает в тех случаях, когда механизм Docker пытается повторно запустить контейнер после неудачной первой попытки.  

FROM debian
RUN apt-get update && apt-get install -y cowsay fortune
COPY entrypoint.sh /
ENTRYPOINT ["/entrtypoint.sh"]

ENTRYPOINT -эта инструкция позволяет определить выполняемый файл, который будет вызываться для обработки любых аргументов, переданных в команду docker run.  

Инструкция COPY просто копирует файл из файловой системы хоста в файловую систему образа, где первый аргумент определяет файл хоста, а второй – целевой путь, таким образом, эта инструкция очень похожа на обычную команду cp.  


Для установления соединения между контейнерами в сети используется команда --link.  

Установление соединения определяется аргументом --link myredis:redis в команде docker run. Docker получает информацию о том, что нам нужно установить
соединение между новым контейнером и существующим контейнером myredis, и в новом контейнере ссылка на существующий должна быть обозначена именем
redis. Для этого Docker создает в файле нового контейнера /etc/hosts запись redis, указывающую на IP-адрес контейнера myredis. Это позволяет нам пользоваться именем хоста redis непосредственно в командной строке redis-cli, без дополнительного определения пути к нему или поиска IP-адреса контейнера Redis. После этого выполняется команда СУБД Redis ping для проверки правильности установленного соединения с Redis-сервером перед добавлением и извлечением каких-либо данных с помощью команд set и put.  

Все выглядит замечательно, но остался один вопрос: как сохранить наши данные и создать их резервную копию? Для этого не следует использовать стандартную файловую систему контейнера, необходима возможность простого совместного использования хранилища данных контейнером и хостом или другими контейнерами. Docker предоставляет такую возможность посредством реализации концепции томов. Тома (volumes) – это файлы или каталоги, которые смонтированы непосредственно на хосте и не являются частью каскадно-объединенной файловой системы. Это означает, что другие контейнеры могут совместно использовать их, и все изменения будут сразу же фиксироваться в файловой системе хоста. Существуют два способа объявления каталога как тома: использование инструкции VOLUME в Dockerfile или включение флага -v в команду docker run. Ниже приведены примеры реализации обоих способов с одинаковым результатом – определение каталога /data как тома внутри контейнера:  

VOLUME /data
или
$ docker run -v /data test/webserver 

По умолчанию заданный каталог или файл будет смонтирован на хосте внутри каталога, в котором был установлен Docker (обычно это каталог /var/lib/docker/).  

КАК СОЗДАЮТСЯ ОБРАЗЫ  
Для команды docker build необходим Dockerfile и контекст создания образа (build context) (который может быть пустым). Контекст создания – это набор локальных файлов и каталогов, к которым можно обращаться из инструкций ADD и/или COPY в Dockerfile и которые обычно определяются как путь к нужному каталогу. Например мы использовали команду создания образа:  

            docker build -t test/cowsay-dockerfile .
            
которая определяла контекст создания как '.', то есть текущий рабочий каталог. Все файлы и каталоги, расположенные по указанному пути, формируют контекст создания образа и передаются в демон Docker как часть процесса создания. В тех случаях, когда контекст не определен, – если задан только URL для Dockerfile или содержимое Dockerfile передается по программному каналу из стандартного потока ввода (STDIN), – контекст создания данного образа считается пустым.  

Поскольку контекст создания образа полностью включается в tar-архив и передается в демон Docker, не используйте для этой цели каталога, в котором содержится большое количество файлов.  

В качестве контекста создания образа разрешается указывать git-репозиторий. В этом случае клиент Docker создает клон такого репозитория и всех подчиненных модулей во временном каталоге, который затем передается в демон Docker как контекст создания образа.  

Для удаления ненужных файлов из контекста создания образа можно воспользоваться файлом .dockerignore. Этот файл должен содержать имена исключаемых файлов, разделенных символами перехода на новую строку. Допускаются символы шаблонов * и ?. Например, можно сформировать .dockerignore со следующим содержимым:

    .git  
    */.git  
    */*/.git  
    *.sw?  

Из контекста исключается файл или каталог .git в корневом каталоге контекста создания образа, но при этом в контекст включается такой файл в любом
подкаталоге (таким образом .git исключается, но dir1/.git1 включается).

Из контекста исключается файл или каталог .git, расположенный в подкаталоге одним уровнем ниже корневого каталога (таким образом dir1/.git исключается, но .git и dir1/dir2/.git включаются).

Из контекста исключается файл или каталог .git, расположенный в подкаталоге двумя уровнями ниже корневого каталога (таким образом dir1/dir2/.git
исключается, но .git и dir1/.git включаются).

Из контекста исключаются файлы test.swp, test.swo и bla.swp, но в контексте остается файл dir1/test.swp.  


УРОВНИ ОБРАЗА!!!
Каждая инструкция в Dockerfile приводит к появлению нового уровня (layer) образа, который также может участвовать в запуске контейнера. Новый уровень создается во время запуска контейнера с использованием образа предыдущего уровня при выполнении соответствующей инструкции Dockerfile и с сохранением нового образа. После успешного завершения выполнения инструкции Dockerfile вспомогательный контейнер удаляется, если в команде не был задан аргумент --rm=false Так как результатом выполнения каждой инструкции является создание статического образа – в сущности, это файловая система и некоторые метаданные, – все активные процессы в данной инструкции будут завершены. Поэтому, несмотря на возможность инициализации в инструкции RUN долговременных процессов, подобных демонам СУБД и SSH, любые активные процессы прекратят свою работу при обработке следующей инструкции или при запуске контейнера. Если необходим сервис или процесс, запускаемый вместе с контейнером, его следует инициализировать с помощью инструкции ENTRYPOINT или CMD.  

docker build -t echotest .
Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM busybox:latest
latest: Pulling from library/busybox
bdbbaa22dec6: Pull complete 
Digest: sha256:6915be4043561d64e0ab0f8f098dc2ac48e077fe23f488ac24b665166898115a
Status: Downloaded newer image for busybox:latest
 ---> 6d5fcfe5ff17
Step 2/3 : RUN echo "This should work"
 ---> Running in ffb9b63604e0
This should work
Removing intermediate container ffb9b63604e0
 ---> 04e67ed44ef4
Step 3/3 : RUN /bin/bash -c echo "This won't"
 ---> Running in c530b3872874
/bin/sh: /bin/bash: not found
The command '/bin/sh -c /bin/bash -c echo "This won't"' returned a non-zero code: 127

Running in ffb9b63604e0 - Идентификатор временного контейнера Docker, запускаемого для выполнения инструкций RUN.  
This should work - выполнение команды во временном контейнере
Removing intermediate container ffb9b63604e0 -удаление временного контейнера
 ---> 04e67ed44ef4 - Идентификатор образа, созданного из временного контейнера.  

запустим образ созданный из временного контейнера  

docker run -it 04e67ed44ef4  
/ # /bin/bash -c echo "hi"  
sh: /bin/bash: not found -  в образ busybox не включена командная оболочка bash.  

Иногда возникает потребность в использовании небольшого, но полноценного дистрибутива Linux. Если действительно необходим предельный минимализм, рекомендуется обратить внимание на образ alpine размером всего 5 Мб, при этом содержащий мощный менеджер пакетов для простой установки приложений и инструментальных средств. Если нужен образ с более широкими возможностями, я обычно пользуюсь одним из образов debian, которые по размеру намного меньше образов самого популярного дистрибутива ubuntu, но пакетная база у них одна и та же.  

Следует отметить, что при запуске команды docker build Docker считывает инструкцию FROM и пытается скачать заданный образ, если его нет в локальной системе. Если такой образ существует локально, Docker использует его без проверки доступности новой версии. Это означает, что команда docker build не может гарантировать, что вызываемый образ соответствует самой новой версии, поэтому необходимо явно выполнить команду docker pull для всех родительских образов или удалить их, чтобы команда docker build загрузила самые новые их версии.  


ИНСТРУКЦИИ Dockerfile  
В некоторых инструкциях (RUN, CMD и ENTRYPOINT) допускается использование как формата командной оболочки, так и формата exec. Формат exec принимает JSON-массив (например, ["executable", "param1", "param2"]), предполагая, что первый элемент массива является именем выполняемого файла, а остальные элементы представляют параметры, передаваемые при запуске. Формат командной оболочки – строка произвольной формы, передаваемая для интерпретации в /bin/sh -c. Используйте формат exec, чтобы избежать случайного искажения строк командной оболочки, или в тех случаях, когда образ не содержит /bin/sh.

ADD
Копирует файлы из контекста создания или из удаленных URL-ссылок в создаваемый образ. Если архивный файл добавляется из локального пути, то он будет
автоматически распакован.  

CMD
Запускает заданную инструкцию во время инициализации контейнера. Если была определена инструкция ENTRYPOINT, то заданная здесь инструкция будет интерпретироваться как аргумент для ENTRY POINT (в этом случае необходимо использовать формат exec). Инструкция CMD замещается любыми аргументами, указанными в команде docker run после имени образа. В действительности выполняется только самая последняя инструкция CMD, а все предыдущие инструкции CMD будут отменены (в том числе и содержащиеся в основных образах). (простыми словами - указывается какая команда будет запущена при старте имейджа) 

COPY
Используется для копирования файлов из контекста создания в образ. Имеет два формата: COPY источник цель и COPY ["источник", "цель"] – оба копируют
файл или каталог из «источник» в контексте создания в «цель» внутри контейнера. Следует обратить особое внимание на невозможность указания путей «источника», расположенных вне пределов контекста создания (например, нельзя указать для копирования файл ../another_dir/myfile).  

ENTRYPOINT
Определяет выполняемый файл (программу) (и аргументы по умолчанию), запускаемый при инициализации контейнера. В эту выполняемую программу передаются как аргументы любые инструкции CMD или аргументы команды docker run, записанные после имени образа. Инструкции ENTRYPOINT часто используются для организации скриптов запуска, которые инициализируют переменные и сервисы перед обработкой всех передаваемых в образ аргументов.  

EXPOSE
Сообщает механизму Docker о том, что в данном контейнере будет существовать процесс, прослушивающий заданный порт или несколько портов. Механизм Docker использует эту информацию при установлении соединения между контейнерами или при открытии портов для общего доступа при помощи аргумента -P в команде docker run.  

ENV
Определяет переменные среды внутри образа. На эти переменные можно ссылаться в последующих инструкциях. Например:
...
ENV MY_VERSION 1.3
RUN apt-get install -y mypackage=$MY_VERSION  

RUN
Запускает заданную инструкцию внутри контейнера и сохраняет результат.  

WORKDIR
Определяет рабочий каталог для всех последующих инструкций RUN, CMD, ENTRYPOINT, ADD, COPY. Инструкцию можно использовать несколько раз. Допускается указание относительных путей, при этом итоговый путь определяется относительно ранее указанного рабочего каталога WORKDIR.  

УСТАНОВЛЕНИЕ СВЯЗИ КОНТЕЙНЕРОВ С ВНЕШНИМ МИРОМ
Допустим, вы запустили веб-сервер внутри контейнера. Но как обеспечить связь сервера с внешним миром? Ответ прост – открыть нужные порты для общего доступа с помощью аргументов -p или -P в команде запуска. Такая команда перенаправляет порты хоста в контейнер.  

            $ docker run -d -p 8000:80 nginx  

Аргумент -p 8000:80 сообщил механизму Docker о необходимости перенаправления порта 8000 хоста на порт 80 в контейнере. В качестве альтернативы при использовании аргумента -P механизм Docker должен автоматически выбрать свободный порт для перенаправления с хоста в контейнер.  

Главное преимущество использования аргумента -P заключается в устранении дополнительного уровня ответственности за корректное назначение портов, что особенно важно при наличии нескольких контейнеров с портами, открытыми для общего доступа. Чтобы определить номера портов, назначенные механизмом Docker, можно выполнить команду docker port.  

Управление данными с помощью томов и контейнеров данных
Тома (volumes) Docker – это каталоги которые не являются частью файловой системы UnionFS конкретного контейнера а представляют собой обычные каталоги в файловой системе хоста, но могут быть смонтированы как отдельные файловые системы (bind mounting) внутри контейнера.
Существуют три различных способа инициализации томов. Важно хорошо понимать различия между этими способами. Во-первых, можно объявить том при
запуске контейнера с помощью флага -v: 

            $ docker run -it --name container-test -h CONTAINER -v /data debian /bin/bash  
            root@CONTAINER:/# ls /data  
            root@CONTAINER:/#  

Здесь каталог /data внутри контейнера станет томом. Любые файлы, которые данный образ сохранил в каталоге /data, копируются на этот том. Мы можем проверить место расположения данного тома в файловой системе хоста, выполнив команду docker inspect на хосте из новой командной оболочки:  

            $ docker inspect -f {{.Mounts}} container-test
            [{5cad... /mnt/sda1/var/lib/docker/volumes/5cad.../_data /data local true}]

Здесь том /data/ в контейнере представляет собой просто ссылку на каталог /var/lib/docker/volumes/5cad.../_data в файловой системе хоста. Чтобы проверить это на практике, можно добавить файл в указанный каталог хоста  

            $ sudo touch /var/lib/docker/volumes/5cad.../_data/test-file

Этот файл сразу же можно увидеть внутри контейнера:  

            $ root@CONTAINER:/# ls /data
            test-file  

Второй способ – объявление тома с помощью инструкции VOLUME в файле Dockerfile:  

FROM debian:wheezy
VOLUME /data  

Результат будет в точности тот же самый, что при использовании ключа -v в команде docker run.  
volumes ???  

Третий способ состоит в расширении аргумента -v команды docker run с явным указанием связываемого каталога хоста в формате -v HOST_DIR:CONTAINER_DIR. Этот
способ нельзя использовать в Dockerfile (так как он нарушает принцип переносимости и создает угрозу безопасности).  

$ docker run -v /home/adrian/data:/data debian ls /data

Здесь каталог файловой системы хоста /home/adrian/data монтируется как /data в контейнере. Все файлы, уже существующие в каталоге /home/adrian/data,
становятся доступными внутри контейнера. Если каталог /data ранее существовал в контейнере, то его содержимое будет скрыто созданным томом. В отличие от
других вариантов вызова, никакие файлы из образа не копируются в том, и этот том не будет удален механизмом Docker (то есть команда docker rm -v не удаляет
том, который монтируется на каталог, указанный пользователем).  

совместное использование данных  ???

Тома удаляются, только если:
 - контейнер, содержащий тома, был удален командой docker rm -v или в команду docker run был включен флаг --rm, а также при соблюдении следующих условий:
 - отсутствие контейнеров, установивших связь с удаляемыми томами;
 - удаляемому тому не соответствует какой-либо каталог файловой системы хоста (то есть при создании тома не использовался синтаксис с ключом -v HOST_DIR:CONTAINER_DIR).

КОМАНДА RUN  
docker run – это команда запуска новых контейнеров
-a, --attach - подключает заданный поток (STDOUT и прочие) к терминалу. Если ключ не задан, то подключаются поток вывода stdout и поток ошибок stderr. Если ключ
не задан и при этом контейнер запускается в интерактивном режиме (-i), то подключается еще и поток ввода stdin. Несовместим с ключом -d.  

-d, --detach - запускает контейнер в режиме «отключения от всех потоков». Команда запускает контейнер в фоновом режиме (background mode) и возвращает идентификатор (ID) контейнера.

-i --interactive - поддерживает доступность открытого потока stdin (даже если он не был подключен). Как правило, используется вместе с ключом -t для запуска контейнера в интерактивном режиме. Например:

$ docker run -it debian /bin/bash
root@bd0f26f928bb:/# ls

-t, --tty - создает псевдоустройство TTY (терминал). Как правило, используется вместе с ключом -i для запуска контейнера в интерактивном режиме.  

-h --hostname - устанавливает для запускаемого контейнера заданное имя Unix-хоста. Например:

docker run -h "myhost" debian hostname
myhost

--name NAME - Присваивает контейнеру имя NAME. В дальнейшем это имя может использоваться для обращения к данному контейнеру в других командах Docker.


docker create - Создает контейнер из заданного образа, но не запускает его. Чтобы запустить созданный контейнер, нужно выполнить команду docker start.

docker rm - удаляет один или несколько контейнеров. Возвращает имена или идентификаторов успешно удаленных контейнеров. 

docker info - выводит различную информацию о системе Docker и хосте, на котором она работает
docker build - создает образ из файла Dockerfile.
docker commit - создает образ из указанного контейнера.  
 
docker system prune -a
docker run ..... -e PORT=4000 ... - env переменная  


docker logs {container_id}

docker exec {container_id} ls - эта команда идет внутрь контейнера, запускает команду(ls) и этот вывод возвращает нам  

docker exec -ti {container_id} bash - проанализировать внутренности контейнера

отличия docker run от docker start ?????

read/write layer => Container layer
read layers => image layers  

docker run -d -p 8080:4000 -e PORT=4000 -v $PWD/../container-data:/app/data node_2

в данном примере - $PWD/../container-data:/app/data - означает синхронизировать фолдер на локальной машине(../container-data) с фолдером внутри контейнера(/app/data)  


docker run -it ubuntu /bin/bash
root@3a5cb5ee2b7c:/# cat /etc/os-release
NAME="Ubuntu"
VERSION="18.04.3 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.3 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic

!!! - ll

docker info 


unix socket
tcp socket

сейчас мы используем один и тот же каталог на хосте и внутри контейнера, а не его копию из образа.???????

Ядро Linux использует идентификаторы пользователей UID и идентификаторы групп GID для идентификации пользователей и определения их прав доступа.
Преобразование числовых идентификаторов UID и GID в символьные идентификаторы выполняется операционной системой в пространстве пользователя. Поэтому идентификаторы пользователей UID в контейнере совпадают с аналогичными UID на хосте, но пользователи и группы, созданные внутри контейнера, не передаются на хост. Из-за этого возникает побочный эффект – может возникать
беспорядок в правах доступа, а одни и те же файлы могут принадлежать одному пользователю внутри контейнера и другому пользователю вне контейнера. В качестве примера рассмотрим изменение владельца конкретного файла:

$ ls -l test-file
-rw-r--r-- 1 docker staff 0 Dec 28 18:26 test-file
$ docker run -it -v $(pwd)/test-file:/test-file debian bash
root@e877f924ea27:/# ls -l test-file
-rw-r--r-- 1 1000 staff 0 Dec 28 18:26 test-file
root@e877f924ea27:/# useradd -r test-user
root@e877f924ea27:/# chown test-user test-file
root@e877f924ea27:/# ls -l /test-file
-rw-r--r-- 1 test-user staff 0 Dec 28 18:26 /test-file
root@e877f924ea27:/# exit
exit
docker@boot2docker:~$ ls -l test-file
-rw-r--r-- 1 999 staff 0 Dec 28 18:26 test-file  

Необходимо включать инструкцию USER для определения пользователя во все файлы Dockerfile (или для изменения пользователя в скриптах для инструкций ENTRYPOINT или CMD). Если этого не сделать, то внутри контейнера все процессы будут запускаться от имени суперпользователя root. Так как идентификаторы пользователя в контейнере и на хосте одинаковы, после взлома контейнера извне нарушитель получит права суперпользователя root на хост-компьютере.  


DOCKER COMPOSE  

identidock: (1)
  build: .  (2)
  ports:    (3)
    - "5000:5000"
  environment:   (4)
  ENV: DEV
  volumes:       (5)
    - ./app:/app

(1) - В первой строке объявляется имя создаваемого контейнера. В одном YAML-файле можно определить несколько контейнеров (часто называемых сервисами на диалекте Compose).  
(2) - Ключ build сообщает Compose, что образ для данного контейнера должен быть создан из Dockerfile, расположенного в текущем каталоге (.). Каждое определение контейнера должно содержать либо ключ build, либо ключ image. Для ключей image задается тег или идентификатор образа, из которого создается контейнер, по аналогии с аргументом image в команде docker run.  
(3) - Ключ ports полностью аналогичен аргументу -p в команде docker run и служит для объявления открытых портов. Здесь связывается порт 5000 в контейнере с портом 5000 на хосте.  
(4) - Ключ environment полностью аналогичен аргументу -e в команде docker run и служит для определения значений переменных среды в контейнере. Здесь для переменной ENV определяется значение DEV, чтобы запустить веб-сервер Flask в режиме разработки.  
(5) - Ключ volumes полностью аналогичен аргументу -v в команде docker run и служит для определения томов. Здесь определено монтирование подкаталога app из текущего каталога на каталог     /app внутри контейнера точно так же, как мы делали раньше, чтобы можно было вносить изменения в код прямо с хоста.  

docker-compose up - Запуск всех контейнеров, определенных в Compose-файле. Вывод журнальных записей объединяется в один поток. В большинстве случаев используется аргумент -d для запуска Compose в фоновом режиме.  

docker-compose build - Пересоздание всех образов, созданных из файлов Dockerfile. Команда up будет создавать образы, только если они не существовали ранее, поэтому команду
build следует использовать при необходимости обновления образов.  

docker-compose run - Одноразовый запуск контейнера с выполнением одной команды (не в качестве сервиса).
docker-compose stop - Остановка контейнеров без их удаления.
docker-compose rm - Удаление остановленных контейнеров.  

Обычный порядок работы начинается с выполнения команды docker-compose up
-d для запуска приложения. Команды docker-compose logs и ps могут использоваться для проверки состояния приложения и как вспомогательное средство при отладке.
После внесения изменений в исходный код нужно выполнить docker-compose
build, затем docker-compose up -d. При этом будет создан новый образ и заменен работающий контейнер.